This implementation try to schedule the AccountActor over a thread pool and while maintaining the execution of the internal state manupulation operations on a single thread at a time. This allows to support many instances of the Actor object over limited number of actual threads. 

If all the operations of the class happens on a single thread (like in case of [Active object](https://en.wikipedia.org/wiki/Active_object)), then thread safety is guaranteed. All operations are sequential and single threaded. Note, there only a single thread or a pool with only single thread is used. Its not same as pool of mulitple threads and one thread is assigned a time. 

To be able to use pool of threads and not just single thread and still want to achieve single thread safely, we need to club all operations under a single task which is scheduled on a thread pool. This method should be entry points for all operations on that object and is treated as the task. From a threading perspective it will look like a single task/method, calling multiple other methods. (These multiple other methods are never called indivisually from a thread). This ensures that only one modification is happening to the class at a given point of time only from a single thread. (No simultanious modifications from multiple threads). This is similar to Akka actor having a single method with lots of cases for different messages. This ensures that only a single thread is performing operations on the object. This allows us to create lots of objects of this class and map them over a limited thread pool. 

Following paragram on Thread confinement from Java concurrency in Practice might also help.

> Another common application of thread confinement is the use of pooled JDBC (Java Database Connectivity) Connection objects. The JDBC specification does not require that Connection objects be thread-safe.[9] In typical server applications, a thread acquires a connection from the pool, uses it for processing a single request, and returns it. Since most requests, such as servlet requests or EJB (Enterprise JavaBeans) calls, are processed synchronously by a single thread, and the pool will not dispense the same connection to another thread until it has been returned, this pattern of connection management implicitly confines the Connection to that thread for the duration of the request.
